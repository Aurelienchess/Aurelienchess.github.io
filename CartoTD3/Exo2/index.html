<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>TD3 : Terre 3D + Leaflet</title>
<style>
html, body { margin:0; height:100%; overflow:hidden; background:#000; }
#earth3d { position:absolute; top:0; left:0; width:100%; height:100%; }
#map { position:absolute; top:10px; left:10px; width:500px; height:300px; z-index:100; border:2px solid #fff; border-radius:6px; }
#info { position: absolute; left:10px; top:10px; color:#000; font-family:sans-serif; z-index:200; }
</style>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/"
  }
}
</script>
</head>

<body>
<div id="info">TD3 — Terre 3D + Leaflet</div>
<div id="earth3d"></div>
<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

const container3D = document.getElementById('earth3d');
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(60, container3D.clientWidth/container3D.clientHeight, 0.1, 1000);
camera.position.set(0, 0, 3);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(container3D.clientWidth || window.innerWidth, container3D.clientHeight || window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
container3D.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff,0.6));
const dir = new THREE.DirectionalLight(0xffffff,1);
dir.position.set(5,3,5);
scene.add(dir);

const texLoader = new THREE.TextureLoader();
const earthTexture = texLoader.load('https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg');

const earth = new THREE.Mesh(
  new THREE.SphereGeometry(1,64,64),
  new THREE.MeshPhongMaterial({ map: earthTexture })
);

const earthGroup = new THREE.Group();
earthGroup.add(earth);
scene.add(earthGroup);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

function latLonToVector3(lat, lon, radius=1){
  const phi = (90-lat)*(Math.PI/180);
  const theta = (lon+180)*(Math.PI/180);
  const x = -radius*Math.sin(phi)*Math.cos(theta);
  const z = radius*Math.sin(phi)*Math.sin(theta);
  const y = radius*Math.cos(phi);
  return new THREE.Vector3(x,y,z);
}

function createMarker(color=0xff0000,size=0.02){
  return new THREE.Mesh(
    new THREE.SphereGeometry(size,16,16),
    new THREE.MeshBasicMaterial({color})
  );
}

/*if(navigator.geolocation){
  navigator.geolocation.getCurrentPosition(pos=>{
    const {latitude,longitude} = pos.coords;
    const v = latLonToVector3(latitude,longitude,1.01);
    const marker = createMarker(0x00ff00);
    marker.position.copy(v);
    scene.add(marker);
  });
}*/

async function addCountryFlags(){
  const res = await fetch('https://restcountries.com/v3.1/all?fields=name,flags,latlng');
  const countries = await res.json();
  const subset = countries.slice(0,200);
  subset.forEach(c=>{
    if(!c.latlng || !c.flags || !c.flags.png) return;
    const [lat,lon] = c.latlng;
    const pos = latLonToVector3(lat,lon,1.03);
    const flagTex = texLoader.load(c.flags.png);
    const plane = new THREE.Mesh(
      new THREE.PlaneGeometry(0.05,0.03),
      new THREE.MeshBasicMaterial({ map: flagTex, transparent:true, side: THREE.FrontSide, depthTest:true })
    );
    plane.position.copy(pos);
    plane.lookAt(pos.clone().multiplyScalar(2));
    earthGroup.add(plane);
    plane.userData = { lat, lon, name: c.name.common };
  });
}
addCountryFlags();

function animate(){
  controls.update();
  renderer.render(scene,camera);
  requestAnimationFrame(animate);
}
animate();

window.addEventListener('resize', () => {
  camera.aspect = container3D.clientWidth / container3D.clientHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(container3D.clientWidth, container3D.clientHeight);
});

const map = L.map('map', { zoomControl:false }).setView([0,0],2);
L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png',{ attribution:'© OpenStreetMap' }).addTo(map);

let leafletClickMarker;

map.on('click', e => {
  const { lat, lng } = e.latlng;

  if (leafletClickMarker) {
    map.removeLayer(leafletClickMarker);
  }

  leafletClickMarker = L.marker([lat, lng]).addTo(map);

  const target = latLonToVector3(lat, lng, 1);
  earthGroup.rotation.set(0, 0, 0);
  const theta = Math.atan2(target.x, target.z);
  const phi = Math.asin(target.y / target.length());
  earthGroup.rotation.y = -theta;
  earthGroup.rotation.x = phi;
});


const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
container3D.addEventListener('click', e=>{
  const rect = container3D.getBoundingClientRect();
  mouse.x = ((e.clientX - rect.left)/rect.width)*2-1;
  mouse.y = -((e.clientY - rect.top)/rect.height)*2+1;
  raycaster.setFromCamera(mouse,camera);
  const intersects = raycaster.intersectObjects(earthGroup.children,true);
  if(intersects.length>0){
    const obj = intersects[0].object;
    if(obj.userData.lat!==undefined){
      map.setView([obj.userData.lat,obj.userData.lon],4);
    }
  }
});
</script>
</body>
</html>
